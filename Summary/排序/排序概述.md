## 排序的环境

快排可不一定是个好方法


##### 这组数据有什么特征？

1. 包含大量重复的元素
   三路快排(java)？
2. 是否大部分数据距离它正确的位置很近？（近乎有序）
   example： 银行的业务，先发生，先完成，极少数耗时长的业务才会后完成。如果按照发生时间排序，那这组数据就是近乎有序的。
   插入排序是更好的选择。
3. 是否数据的取值范围是非常有限的？
   example：对学生的高考分数进行排序
   计数排序或许是更好的选择

##### 对排序有没有额外的要求？
1. 是否需要稳定的排序
   如果是的话，快排恐怕不是好的选择，归并排序是个好的选择。

##### 数据的存储状况是怎样的？
1. 是否使用链表存储？
   此时快排不是很适合了，归并是更好的选择
2. 数据的大小有多少，是否可以全部装载在内存里？
   如果数据量很大，或者内存很小，那我们就要考虑外排序算法。
   
   

## 排序的稳定性

> 排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同

稳定的排序

- 冒泡排序

  冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的

- 插入排序

  如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

- 归并排序

- 基数排序
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的排序算法。

不稳定的排序

- 选择排序

  序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

- 希尔排序(shell)
  希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

- 快速排序

  不稳定

- 堆排序
    我们知道堆的结构是节点i的孩子为2*i和2 *i +1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。
    
    在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

  